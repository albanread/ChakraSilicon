# Quick Start: Analyzing x64 to Fix ARM64

**Goal:** Use the working x64 Mac JIT to understand and fix the broken ARM64 Mac JIT.

---

## TL;DR

```bash
# 1. Run x64 tests (should all pass)
./dist/chjitx64/ch examination/test_jit_to_int.js

# 2. Debug x64 to understand how it works
lldb ./dist/chjitx64/ch
(lldb) command source examination/debug_x64_thunk.lldb
(lldb) run examination/test_jit_to_int.js

# 3. Document findings in examination/X64_FINDINGS.md

# 4. Compare with ARM64 source code and fix it
```

---

## What We Have

### ‚úÖ Working x64 Build (under Rosetta)
- Binary: `./dist/chjitx64/ch`
- Library: `./dist/chjitx64/libChakraCore.dylib`
- Status: All JIT‚ÜíINT calls work perfectly

### ‚ùå Broken ARM64 Build (native Apple Silicon)
- Binary: `./dist/chjita64/ch`
- Library: `./dist/chjita64/libChakraCore.dylib`
- Status: JIT‚ÜíINT calls hang infinitely

### üìã Test Suite
- File: `examination/test_jit_to_int.js`
- Tests: 10 different JIT‚ÜíINT call patterns
- x64 result: All PASS ‚úÖ
- ARM64 result: Hangs on Test 1 ‚ùå

---

## The Problem

When JIT-compiled JavaScript code calls an interpreter-mode built-in function (like `Math.max`), the ARM64 implementation hangs. The call chain is:

```
JIT Code ‚Üí Static Thunk ‚Üí Dynamic Thunk ‚Üí Interpreter ‚Üí Built-in Function
           ^^^^^^^^^^^^
           THIS PART IS BROKEN ON ARM64
```

The static thunk is generated by `InterpreterThunkEmitter.cpp` and it's different for each platform. The x64 version works, ARM64 doesn't.

---

## What We Need to Learn from x64

See `critical_unknowns.md` for the complete list, but the key unknowns are:

### üî¥ P0 - Critical
1. **What does the dynamic thunk do?** (We need to find and understand it)
2. **How are parameters passed?** (Registers? Stack? Both?)
3. **What does the ARGUMENTS macro expect?** (Stack layout? Offsets?)

### üü° P1 - Important
4. **What's the complete call chain?** (JIT ‚Üí Static ‚Üí Dynamic ‚Üí INT)
5. **How does x64 differ from ARM64 source?** (Code comparison)

---

## Your Debugging Mission

### Phase 1: Understand x64 (2-4 hours)

Follow `X64_DEBUGGING_GUIDE.md` to:

1. **Set breakpoints** in the interpreter transition code
2. **Capture state** (registers, stack, disassembly)
3. **Document findings** in `examination/X64_FINDINGS.md`

Key breakpoint: `InterpreterStackFrame::InterpreterHelper`

When it hits, document:
- Register values (rdi, rsi, rdx, rcx, r8, r9)
- Stack layout (what's where)
- Thunk disassembly (how it sets things up)

### Phase 2: Compare with ARM64 Source (1-2 hours)

File: `ChakraCore/lib/Runtime/Language/InterpreterThunkEmitter.cpp`

Find the ARM64 thunk generation code and compare with what x64 actually does:

```bash
# Search for x64 thunk
grep -A 50 "TARGET_64" ChakraCore/lib/Runtime/Language/InterpreterThunkEmitter.cpp

# Search for ARM64 thunk
grep -A 50 "TARGET_ARM64" ChakraCore/lib/Runtime/Language/InterpreterThunkEmitter.cpp

# Compare
diff -u x64_section.txt arm64_section.txt
```

### Phase 3: Identify the Bug (30 min - 2 hours)

Answer these questions:
- What does x64 do that ARM64 doesn't?
- What does ARM64 do wrong?
- What assumptions are violated?

### Phase 4: Fix It (2-4 hours)

Based on understanding from Phase 1-3:
1. Modify ARM64 thunk generation code
2. Rebuild: `./scripts/build_target.sh chjita64`
3. Test: `./dist/chjita64/ch examination/test_jit_to_int.js`
4. If it hangs, add logging and iterate
5. Once working, run full test suite

---

## Quick Command Reference

### Build Commands
```bash
# Build x64 (for reference/debugging)
arch -x86_64 ./scripts/build_target.sh chjitx64

# Build ARM64 (what we're fixing)
./scripts/build_target.sh chjita64

# Build all variants
./scripts/build_all_and_pack.sh
```

### Test Commands
```bash
# Run test on x64 (should pass)
./dist/chjitx64/ch examination/test_jit_to_int.js

# Run test on ARM64 (will hang - use Ctrl+C to stop)
timeout 10s ./dist/chjita64/ch examination/test_jit_to_int.js || echo "Timed out (expected)"
```

### Debug Commands
```bash
# Debug x64 with automated script
lldb ./dist/chjitx64/ch
(lldb) command source examination/debug_x64_thunk.lldb
(lldb) run examination/test_jit_to_int.js

# Debug ARM64 manually (be ready to kill it)
lldb ./dist/chjita64/ch
(lldb) breakpoint set -n InterpreterStackFrame::InterpreterHelper
(lldb) run examination/test_jit_to_int.js
# When it hangs: Ctrl+C, then examine state
```

### Useful LLDB Commands
```lldb
# Show all registers
register read

# Show specific registers (x64)
register read rdi rsi rdx rcx r8 r9

# Show specific registers (ARM64)
register read x0 x1 x2 x3 x4 x5 x6 x7

# Show stack
memory read -f x -c 32 $sp

# Disassemble current function
disassemble

# Show backtrace
bt 10

# Set architecture disassembly flavor
settings set target.x86-disassembly-flavor intel
```

---

## Key Files to Know

### Source Code
- `ChakraCore/lib/Runtime/Language/InterpreterThunkEmitter.cpp` - **THE FILE TO FIX**
- `ChakraCore/lib/Runtime/Language/Arguments.h` - ARGUMENTS macro definition
- `ChakraCore/lib/Runtime/Language/InterpreterStackFrame.cpp` - Interpreter helper
- `ChakraCore/lib/Runtime/Language/InterpreterStackFrame.h` - Stack structures

### Documentation
- `examination/critical_unknowns.md` - What we don't understand yet
- `examination/next_steps.md` - Overall ARM64 JIT investigation
- `examination/X64_DEBUGGING_GUIDE.md` - Complete debugging walkthrough
- `examination/QUICK_START.md` - This file

### Test & Debug Tools
- `examination/test_jit_to_int.js` - Test suite for JIT‚ÜíINT calls
- `examination/debug_x64_thunk.lldb` - Automated LLDB debugging script

---

## Expected Timeline

| Phase | Time | Outcome |
|-------|------|---------|
| x64 debugging | 2-4 hours | Complete understanding of working implementation |
| Code comparison | 1-2 hours | Identified differences between x64 and ARM64 |
| Root cause analysis | 0.5-2 hours | Know exactly what's wrong |
| Fix implementation | 2-4 hours | Modified ARM64 thunk code |
| Testing & iteration | 2-8 hours | All tests passing |
| **Total** | **7.5-20 hours** | **Working ARM64 JIT‚ÜíINT calls** |

Much better than weeks of trial-and-error!

---

## Success Metrics

You've succeeded when:

1. ‚úÖ You can draw a diagram showing the complete x64 call chain
2. ‚úÖ You understand exactly what each register/stack slot contains
3. ‚úÖ You know why ARM64 is broken (specific code issue)
4. ‚úÖ All 10 tests in `test_jit_to_int.js` pass on ARM64
5. ‚úÖ You can explain the fix to someone else

---

## Rosetta Info

Rosetta 2 is already installed on your system (verified). It lets you run x86_64 binaries on Apple Silicon.

- **Check if running under Rosetta:** `arch` (returns "x86_64" if yes, "arm64" if no)
- **Force x86_64 execution:** `arch -x86_64 <command>`
- **Our x64 binary automatically uses Rosetta** when you run it

The x64 binary runs slightly slower than native ARM64 (emulation overhead), but for debugging purposes this doesn't matter.

---

## When You Get Stuck

### "Breakpoint never hits"
- Try `-ForceSerialized` flag to disable some optimizations
- Try breaking on thunk generation instead: `breakpoint set -r ".*Thunk.*Emit"`

### "Can't understand the disassembly"
- Refer to x64 instruction reference: https://www.felixcloutier.com/x86/
- Look for patterns: `push/pop`, `mov`, `call`, `jmp`
- Focus on how it manipulates `rsp` (stack pointer)

### "Too much information"
- Start with just answering the 6 critical questions in `critical_unknowns.md`
- Don't worry about understanding everything, just the call chain

### "Still confused after debugging"
- Post your findings (registers, stack, disassembly) and ask for help
- Sometimes a second set of eyes helps
- Review the ABI specifications (System V AMD64 ABI for x64)

---

## Next Actions

**Right now:**
1. Run the x64 test to verify it works: `./dist/chjitx64/ch examination/test_jit_to_int.js`
2. Start debugging session: `lldb ./dist/chjitx64/ch`
3. Load the script: `(lldb) command source examination/debug_x64_thunk.lldb`
4. Run it: `(lldb) run examination/test_jit_to_int.js`

**When breakpoint hits:**
1. Capture everything (follow `X64_DEBUGGING_GUIDE.md`)
2. Create `examination/X64_FINDINGS.md` with your notes
3. Move to Phase 2 (code comparison)

---

## Questions?

- See `X64_DEBUGGING_GUIDE.md` for detailed walkthrough
- See `critical_unknowns.md` for what we're trying to learn
- See `next_steps.md` for broader ARM64 JIT context

---

**Remember:** We're done guessing. Now we're learning how it actually works, then applying that knowledge. üî¨

Good luck! üöÄ